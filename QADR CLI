usr/bin/env bash
# git-optional-commit.sh
# Utility to stage/commit/push with a few convenient flags.
# Usage examples are provided in READ.
git init
git add .
git commit -m "Initial: SULTAN-GHOST-CONSOLE project layout (Apache-2.0)"
git branch -M main
# Ø§Ø¶Ù Ø§Ù„Ø±ÙŠÙ…ÙˆØª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ (SSH/HT#!/bin/bash
 #!/bin/bash
// in qadr-cli helper
const crypto = require('crypto');

function makeProxiedUrl(originalUrl, proxyBase) {
  const key = process.env.HMAC_KEY || 'change_me';
  const sig = crypto.createHmac('sha256', key).update(originalUrl).digest('hex');
  const b64 = Buffer.from(originalUrl).toString('base64url');
  return `${proxyBase.replace(/\/$/,'')}/${sig}/${b64}`;
// Ù…Ø«Ø§Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù…
// makeProxiedUrl('https://example.com/image.jpg','https://proxy.yourdomain.com')
# Git helper: commit + auto badge + safety check
# ÙØ­Øµ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ (Python/Node)
echo "ğŸ” ÙØ­Øµ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯..."
flake8 qadr/ || echo "âš ï¸ ØªØ­Ø°ÙŠØ±: Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ù…ÙˆØ¬ÙˆØ¯Ø©"
eslint qadr/ || echo "âš ï¸ ØªØ­Ø°ÙŠØ± JS"

# Ø¥Ø¶Ø§ÙØ© ÙƒÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª
git add .

# Ø¥Ù†Ø´Ø§Ø¡ commit ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ
COMMIT_MSG="Auto commit: $(date '+%Y-%m-%d %H:%M:%S')"
git commit -m "$COMMIT_MSG" || echo "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª"

# Push Ø¥Ù„Ù‰ origin main
git push origin main

# Badge: Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø­Ø§Ù„Ø© Ø£Ùˆ ØªØ­Ø¯ÙŠØ« README
BADGE_FILE="docs/badge_status.md"
echo "![QADR CLI Status](https://img.shields.io/badge/status-active-brightgreen)" > $BADGE_FILE
qadr-cli/
â”œâ”€ .gitignore
â”œâ”€ LICENSE
â”œâ”€ README.md
â”œâ”€ CONTRIBUTING.md
â”œâ”€ CODE_OF_CONDUCT.md
â”œâ”€ git-optional-commit.sh
â”œâ”€ setup.sh
â”œâ”€ docs/
â”‚  â””â”€ architecture.md
â”œâ”€ examples/
â”‚  â””â”€ safe_demo_localhost.sh
â”œâ”€ qadr/
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ cli.py-qadr-
---geo-cli
â”‚  â”œâ”€ scanner.py        # Ù…ÙÙ‡ÙŠØ£ Ù„ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· Ù…Ø¹ Ø£Ù‡Ø¯Ø§Ù Ù…ÙØµØ±Ù‘Ø­ Ø¨Ù‡Ø§
â”‚  â”œâ”€ reporters.py
â”‚  â””â”€ utils.py
â””â”€ tests/
   â””â”€ test_scan_safety.py
# Agent in your Git: Automatic setup for SULTAN-AAA-QADR with text-generation-webui, APIs, install, error check, run super code.

set -e  # Exit on error

echo "Cloning text-generation-webui..."
git clone https://github.com/Abdiifahman/text-generation-webui SULTAN-AAA-SYNC || { echo "Clone failed"; exit 1; }
cd SULTAN-AAA-SYNC

echo "Creating files..."
mkdir -p .github/workflows watch_folder .devcontainer
./git-optional-commit.sh -a --samend -m "Amended message" --push

./git-optional-commit.sh -a --no-commit
# script.js (with confirmed Grok API: https://api.x.ai/v1/chat/completions, Bearer auth)
cat << 'EOF' > script.js
const crypto = require('crypto');
const OpenAI = require('openai');
const fs = require('fs').promises;
require('dotenv').config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function grokAnalyze(content) {
  const url = "https://api.x.ai/v1/chat/completions";
  const headers = { "Authorization": `Bearer ${process.env.GROK_API_KEY}`, "Content-Type": "application/json" };
  const data = {
    model: "grok-beta",
    messages: [{ role: "user", content: `Analyze: ${content}` }],
    temperature: 0.2,
    max_tokens: 400
  };
  try {
    const response = await fetch(url, { method: "POST", headers, body: JSON.stringify(data) });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const result = await response.json();
    return result.choices[0].message.content;
  } catch (err) {
    console.error(`Grok error: ${err.message}`);
    return "Fallback: Grok unreachable";
  }
}

function generateOpenAIStyleId(prefix = 'sess') {
  const timestamp = Date.now().toString(36);
  const randomPart = crypto.randomBytes(12).toString('hex');
  return `${prefix}-${timestamp}-${randomPart}`;
}

async function aiAnalysis(report, userInput = 'Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„ÙƒÙ„') {
  const prompt = `Analyze report: ${JSON.stringify(report, null, 2)}. Intent: ${userInput}. JSON: {"suggestions": [], "code_changes": [{"section": "", "change": ""}]} `;
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      max_tokens: 400
    });
    return JSON.parse(completion.choices[0].message.content) || { suggestions: [], code_changes: [] };
  } catch (err) {
    console.error(`OpenAI error: ${err.message}`);
    return { suggestions: ['Fallback'], code_changes: [] };
  }
}

async function loadReport(filePath = 'inputs.txt') {
  try { return JSON.parse(await fs.readFile(filePath, 'utf-8')); } catch { return { error: 'Invalid' }; }
}

async function main() {
  const id = generateOpenAIStyleId('sandbox');
  console.log(`[APP] ID: ${id}`);
  const args = process.argv.slice(2);
  const report = await loadReport(args[0]);
  if (report.error) { console.error(report.error); return; }
  const result = await aiAnalysis(report, args[1] || 'ØªØ­Ù„ÙŠÙ„');
  const grokRes = await grokAnalyze(JSON.stringify(report));
  console.log(`Result: ${JSON.stringify(result, null, 2)}\nGrok: ${grokRes}`);
}

if (require.main === module) main();
EOF

# agent.py (Python with Gemini/Grok)
cat << 'EOF' > agent.py
#!/usr/bin/env python3
import os, subprocess, time, base64, json, requests
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()

GH_PAT = os.getenv("GH_PAT")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GROK_API_KEY = os.getenv("GROK_API_KEY")
REPO = os.getenv("REPO", "Abdiifahman/SULTAN-AAA-SYNC")
WATCH_DIR = "./watch_folder"

def decode_base64(encoded_str):
  try:
    return base64.b64decode(encoded_str).decode('utf-8')
  except Exception as e:
    print(f"Base64 error: {e}")
    return None

def analyze_with_gemini(content):
  if not GEMINI_API_KEY: return print("Gemini key missing.")
  url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
  data = {"contents": [{"parts": [{"text": f"Analyze: {content}"}]}]}
  try:
    r = requests.post(url, json=data, params={"key": GEMINI_API_KEY})
    r.raise_for_status()
    print(f"Gemini: {r.json()['candidates'][0]['content']['parts'][0]['text']}")
  except Exception as e:
    print(f"Gemini error: {e}")

def analyze_with_grok(content):
  if not GROK_API_KEY: return print("Grok key missing. Get from https://x.ai/api")
  url = "https://api.x.ai/v1/chat/completions"
  headers = {"Authorization": f"Bearer {GROK_API_KEY}", "Content-Type": "application/json"}
  data = {
    "model": "grok-beta",
    "messages": [{"role": "user", "content": f"Analyze: {content}"}],
    "temperature": 0.2,
    "max_tokens": 400
  }
  try:
    r = requests.post(url, headers=headers, json=data)
    r.raise_for_status()
    print(f"Grok: {r.json()['choices'][0]['message']['content']}")
  except Exception as e:
    print(f"Grok error: {e}")

def process_file(file_path):
  content = file_path.read_text()
  decoded = decode_base64(content)
  if decoded:
    analyze_with_gemini(decoded)
    analyze_with_grok(decoded)

def watch_directory():
  Path(WATCH_DIR).mkdir(exist_ok=True)
  print(f"Watching: {WATCH_DIR}")
  known_files = {}
  while True:
    for file_path in Path(WATCH_DIR).glob("*"):
      mtime = file_path.stat().st_mtime
      if file_path.name not in known_files or known_files[file_path.name] != mtime:
        print(f"Change in {file_path}")
        known_files[file_path.name] = mtime
        process_file(file_path)
    time.sleep(5)

def main():
  if not all([GH_PAT, GEMINI_API_KEY, GROK_API_KEY]):
    print("Update .env with keys (Grok from https://x.ai/api).")
    return
  watch_directory()

if __name__ == "__main__": main()
EOF

# package.json
cat << EOF > package.json
{"name": "sultan-aaa-sync", "version": "1.0.0", "main": "script.js", "scripts": {"start": "node script.js"}, "dependencies": {"openai": "^4.0.0", "dotenv": "^16.0.0"}}
EOF

# requirements.txt
cat << EOF > requirements.txt
requests==2.31.0
python-dotenv==1.0.0
EOF

# .env
cat << EOF > .env
OPENAI_API_KEY=your-openai-key
GH_PAT=your-gh-pat
GEMINI_API_KEY=your-gemini-key
GROK_API_KEY=your-grok-key  # From https://x.ai/api
REPO=Abdiifahman/SULTAN-AAA-SYNC
NGROK_AUTH_TOKEN=dxoom18@gmail.com:Aaa11223344@1
EOF

# .gitignore
cat << EOF > .gitignore
node_modules/
.env
watch_folder/
__pycache__/
installer_files/
venv/
EOF

# ci.yml
cat << 'EOF' > .github/workflows/ci.yml
name: CI
on: [push, pull_request, workflow_dispatch]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm install
      - run: node script.js inputs.txt "ØªØ­Ù„ÙŠÙ„"
        env: { OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}, GROK_API_KEY: ${{ secrets.GROK_API_KEY }} }
      - uses: actions/setup-python@v4
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: python agent.py
        env: { GH_PAT: ${{ secrets.GH_PAT }}, GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}, GROK_API_KEY: ${{ secrets.GROK_API_KEY }} }
EOF

# inputs.txt
echo '{"data": "Super code test"}' > inputs.txt

# Install deps & check errors
echo "Installing..."
npm install || { echo "NPM error"; exit 1; }
pip install -r requirements.txt || { echo "Pip error"; exit 1; }

# Run super code
echo "Running super code..."
node script.js inputs.txt "ØªØ­Ù„ÙŠÙ„" &
python agent.py &
python server.py --portable --api || { echo "WebUI error"; exit 1; }

# Push
git add .
git commit -m "Auto setup super code" || true
git push origin main || { echo "Push error"; exit 1; }

echo "Setup complete. Update .env keys. Access: http://127.0.0.1:7860"
â€#!/usr/bin/env bash
â€set -euo pipefail

# ======================================================
â€# SULTAN-AAA QADR - Unified CLI (admin bypass support)
â€# - clone/update repo
â€# - encrypt/decrypt per-user .env (admin can bypass)
â€# - verify deps
â€# - run Node + Python + optional server
â€# - manage processes (start/stop/status)
#
â€# Behavior:
â€# - If you (the runner) are the admin, set ADMIN_BYPASS=1 or ADMIN_USER="your-username"
â€#   then the script will NOT prompt for passphrase and will decrypt .env.enc automatically (using a local admin-only key file).
â€# - For non-admin users, the script will ask for a passphrase to decrypt .env.enc (or skip decrypt and run in limited mode).
#
â€# Security note:
â€# - This script does NOT send keys anywhere. All secrets remain local.
â€# - Make sure .env / .env.enc are protected (chmod 600) and never commit plaintext .env.
# ======================================================

â€REPO_URL="https://github.com/Abdiifahman/text-generation-webui"
â€TARGET_DIR="SULTAN-AAA-SYNC"
â€WATCH_DIR="watch_folder"
â€ARTIFACTS_DIR="artifacts"
â€ENV_ENC_FILE=".env.enc"
â€ENV_TEMP_FILE=".env.dec.$$"   # temporary decrypted file (per-run)
â€PIDS_DIR=".pids"
â€LOG_DIR="logs"
â€ADMIN_KEY_FILE=".admin_key"   # optional local admin key file (owner-only)
â€ADMIN_USER="${ADMIN_USER:-}"  # set this env var to your admin OS username if desired
â€ADMIN_BYPASS="${ADMIN_BYPASS:-0}" # set to "1" to bypass prompts (admin only!)

â€mkdir -p "$PIDS_DIR" "$LOG_DIR" "$ARTIFACTS_DIR"

â€err() { echo "ERROR: $*" >&2; }
â€info() { echo "[INFO] $*"; }
â€warn() { echo "[WARN] $*"; }

â€require_cmd() {
â€  if ! command -v "$1" >/dev/null 2>&1; then
â€    err "Required command '$1' not found. Please install it."
â€    exit 1
â€  fi
}

â€check_deps() {
â€  info "Checking dependencies..."
â€  require_cmd git
â€  require_cmd openssl
â€  if ! command -v node >/dev/null 2>&1; then
â€    info "node not found (Node features will be skipped)"
â€  fi
â€  if ! command -v npm >/dev/null 2>&1; then
â€    info "npm not found (Node features will be skipped)"
â€  fi
â€  require_cmd python3
â€  require_cmd pip
â€  info "Dependencies check done (optional tools noted)."
}

â€# Create sample .env if missing
â€cmd_init_encrypt() {
â€  if [ -f "$ENV_ENC_FILE" ]; then
â€    info "$ENV_ENC_FILE already exists. If you want to recreate run: rm -f $ENV_ENC_FILE and re-run this command after creating .env"
â€    return
â€  fi
â€  if [ ! -f ".env" ]; then
â€    cat > .env <<'EOF'
â€# Example .env - replace values and DO NOT commit .env
â€OPENAI_API_KEY=your-openai-key
â€GEMINI_API_KEY=your-gemini-key
â€GROK_API_KEY=your-grok-key
â€GH_PAT=your-gh-pat
â€REPO=Abdiifahman/SULTAN-AAA-SYNC
â€QADR_AES_PASS=your_local_encryption_pass
â€EOF
â€    info "Created example .env. Edit it with your own keys, then run this command again to encrypt."
â€    return
â€  fi

â€  # Admin bypass? If admin and ADMIN_KEY_FILE present, encrypt with admin key automatically
â€  if admin_is_running; then
â€    info "Admin detected: encrypting .env with admin local key (no passphrase prompt)."
â€    if [ ! -f "$ADMIN_KEY_FILE" ]; then
â€      # generate admin key file (restricted)
â€      openssl rand -hex 32 > "$ADMIN_KEY_FILE"
â€      chmod 600 "$ADMIN_KEY_FILE"
â€      info "Admin key generated at $ADMIN_KEY_FILE (permissions 600). Protect this file."
â€    fi
â€    pass=$(cat "$ADMIN_KEY_FILE")
â€    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
â€    chmod 600 "$ENV_ENC_FILE"
â€    info "Encrypted .env saved to $ENV_ENC_FILE (admin key used). Remove plaintext .env if present."
â€    return
â€  fi

â€  # Non-admin flow: ask for passphrase to encrypt
â€  read -s -p "Choose a passphrase to encrypt your .env (you will need it to run): " pass
â€  echo
â€  if [ -z "$pass" ]; then err "Empty passphrase not allowed."; exit 1; fi
â€  openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
â€  chmod 600 "$ENV_ENC_FILE"
â€  info "Encrypted .env saved to $ENV_ENC_FILE. Remove plaintext .env if present."
}

â€# admin detection function
â€admin_is_running() {
â€  # Order of checks:
â€  # 1) If ADMIN_BYPASS=1 set in env, treat as admin (use only on admin machine)
â€  # 2) If ADMIN_USER is set and matches current OS user, treat as admin
â€  # 3) If ADMIN_KEY_FILE exists and readable by current user, treat as admin
â€  # Important: Do not use ADMIN_BYPASS on multi-user systems unless you trust environment security
â€  if [ "${ADMIN_BYPASS:-0}" = "1" ]; then
â€    return 0
â€  fi
â€  local curuser
â€  curuser=$(whoami 2>/dev/null || echo "")
â€  if [ -n "$ADMIN_USER" ] && [ "$curuser" = "$ADMIN_USER" ]; then
â€    return 0
â€  fi
â€  if [ -f "$ADMIN_KEY_FILE" ] && [ -r "$ADMIN_KEY_FILE" ]; then
â€    # ensure only owner can read it
â€    perms=$(stat -c "%a" "$ADMIN_KEY_FILE" 2>/dev/null || echo "")
â€    # require 600 or stricter
â€    if [[ "$perms" == "600" || "$perms" == "400" || "$perms" == "600" ]]; then
â€      return 0
â€    fi
â€  fi
â€  return 1
}

â€# decrypt ENV into temp file; returns 0 on success
â€decrypt_env_prompt() {
â€  if [ ! -f "$ENV_ENC_FILE" ]; then
â€    warn "$ENV_ENC_FILE not found. Run 'init-encrypt' to create an encrypted .env from your .env file."
â€    return 1
â€  fi

â€  # Admin automatic decrypt (no prompt) if admin key present
â€  if admin_is_running; then
â€    info "Admin detected: attempting automatic decrypt using local admin key (no passphrase prompt)."
â€    if [ ! -f "$ADMIN_KEY_FILE" ]; then
â€      err "Admin key file $ADMIN_KEY_FILE missing; cannot auto-decrypt. Use init-encrypt or provide passphrase."
â€      return 1
â€    fi
â€    pass=$(cat "$ADMIN_KEY_FILE")
â€    if ! openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass" 2>/dev/null; then
â€      err "Automatic admin decryption failed (maybe admin key differs)."
â€      [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
â€      return 1
â€    fi
â€    chmod 600 "$ENV_TEMP_FILE"
â€    info "Decrypted .env to $ENV_TEMP_FILE (admin key)."
â€    return 0
â€  fi

â€  # Non-admin: prompt for passphrase
â€  read -s -p "Enter passphrase to decrypt $ENV_ENC_FILE: " pass
â€  echo
â€  if [ -z "$pass" ]; then err "Empty passphrase; abort."; return 1; fi
â€  if ! openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass" 2>/dev/null; then
â€    err "Decryption failed - wrong passphrase or corrupted file."
â€    [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
â€    return 1
â€  fi
â€  chmod 600 "$ENV_TEMP_FILE"
â€  info "Decrypted .env to $ENV_TEMP_FILE."
â€  return 0
}

â€cleanup_temp_env() {
â€  if [ -f "$ENV_TEMP_FILE" ]; then
â€    # try secure delete if shred available, otherwise delete
â€    if command -v shred >/dev/null 2>&1; then
â€      shred -u "$ENV_TEMP_FILE" 2>/dev/null || rm -f "$ENV_TEMP_FILE"
â€    else
â€      rm -f "$ENV_TEMP_FILE"
â€    fi
â€    info "Removed temporary decrypted env."
â€  fi
}

â€_safe_trap_setup() {
â€  trap cleanup_temp_env EXIT INT TERM
}

â€# clone or update repo
â€cmd_clone_or_update() {
â€  if [ -d "$TARGET_DIR/.git" ]; then
â€    info "Directory exists and is a git repo â€” updating..."
â€    pushd "$TARGET_DIR" > /dev/null
â€    git fetch --all --prune
â€    if git show-ref --quiet refs/remotes/origin/main; then
â€      git reset --hard origin/main
â€    else
â€      git reset --hard origin/HEAD
â€    fi
â€    git clean -fd
â€    popd > /dev/null
â€    info "Update complete."
â€  else
â€    info "Cloning ${REPO_URL} into ${TARGET_DIR}..."
â€    git clone --depth 1 "$REPO_URL" "$TARGET_DIR" || { err "Clone failed"; exit 1; }
â€    info "Clone complete."
â€  fi
}

â€# show status
â€cmd_status() {
â€  echo "=== Repo status ==="
â€  if [ -d "$TARGET_DIR/.git" ]; then
â€    pushd "$TARGET_DIR" >/dev/null
â€    git status --short --branch
â€    popd >/dev/null
â€  else
â€    echo "Repository not present."
â€  fi
â€  echo "=== Processes ==="
â€  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
â€    [ -f "$f" ] || continue
â€    pid=$(cat "$f")
â€    if kill -0 "$pid" 2>/dev/null; then
â€      echo "$(basename "$f" .pid): running (pid $pid)"
â€    else
â€      echo "$(basename "$f" .pid): not running (stale pid file)"
â€    fi
â€  done
}

â€# stop processes
â€cmd_stop() {
â€  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
â€    [ -f "$f" ] || continue
â€    pid=$(cat "$f")
â€    if kill -0 "$pid" 2>/dev/null; then
â€      info "Stopping pid $pid..."
â€      kill "$pid"
â€      sleep 1
â€      if kill -0 "$pid" 2>/dev/null; then
â€        warn "Process $pid did not stop, forcing..."
â€        kill -9 "$pid" || true
â€      fi
â€    fi
â€    rm -f "$f"
â€  done
â€  info "All tracked processes stopped."
}

â€# run services: node script.js, python agent.py, optional server.py
â€cmd_run() {
â€  _safe_trap_setup

â€  # ensure repo present
â€  cmd_clone_or_update

â€  # decrypt env (admin bypass if admin)
â€  if ! decrypt_env_prompt; then
â€    err "Cannot continue without decrypted environment."
â€    exit 2
â€  fi

â€  # load env into this shell (but avoid exporting secrets to logs)
â€  set -o allexport
â€  # shellcheck disable=SC1091
â€  source "$ENV_TEMP_FILE"
â€  set +o allexport

â€  # python venv & deps
â€  if [ ! -d "venv" ]; then
â€    python3 -m venv venv || true
â€  fi
â€  # shellcheck disable=SC1091
â€  . venv/bin/activate
â€  pip install --upgrade pip >/dev/null
â€  if [ -f "requirements.txt" ]; then
â€    pip install -r requirements.txt
â€  fi

â€  # node deps
â€  if [ -f "package.json" ] && command -v npm >/dev/null 2>&1; then
â€    npm install --silent || info "npm install returned non-zero"
â€  fi

â€  # start node (if exists)
â€  if [ -f "script.js" ] && command -v node >/dev/null 2>&1; then
â€    info "Starting Node script (script.js)..."
â€    nohup node script.js inputs.txt "ØªØ­Ù„ÙŠÙ„" > "$LOG_DIR/node.log" 2>&1 &
â€    echo $! > "$PIDS_DIR/node.pid"
â€    info "Node started (pid $(cat $PIDS_DIR/node.pid))."
â€  else
â€    info "No script.js or Node not available; skipping Node process."
â€  fi

â€  # start python agent
â€  if [ -f "agent.py" ] && command -v python3 >/dev/null 2>&1; then
â€    info "Starting Python agent (agent.py)..."
â€    nohup python3 agent.py > "$LOG_DIR/agent.log" 2>&1 &
â€    echo $! > "$PIDS_DIR/agent.pid"
â€    info "Python agent started (pid $(cat $PIDS_DIR/agent.pid))."
â€  else
â€    info "No agent.py or Python not available; skipping Python agent."
â€  fi

â€  # optional server.py
â€  if [ -f "server.py" ]; then
â€    info "Starting optional server.py..."
â€    nohup python3 server.py --portable --api > "$LOG_DIR/server.log" 2>&1 &
â€    echo $! > "$PIDS_DIR/server.pid"
â€    info "server.py started (pid $(cat $PIDS_DIR/server.pid))."
â€  else
â€    info "server.py not found; skipping server start."
â€  fi

â€  info "All requested processes have been started. Use './$0 status' to check, './$0 stop' to stop."
â€  # cleanup will be done via trap on exit if script ends
}

â€# alias update
â€cmd_update() { cmd_clone_or_update; }

â€# help
â€cmd_help() {
â€  cat <<'EOF'
â€SULTAN-AAA QADR CLI (admin-bypass capable)

â€Usage:
â€  ./sultan_setup_cli.sh <command>

â€Commands:
â€  init-encrypt    Create .env (if missing) and encrypt it into .env.enc (per-user or admin key).
â€                  - Admin automatic flow: set ADMIN_BYPASS=1 or ADMIN_USER to match your OS username.
â€                  - Admin key file: .admin_key (auto-generated on init for admin).
â€  clone           Clone or update the repository (idempotent).
â€  update          Alias for clone (fetch & reset).
â€  run             Decrypt .env.enc (admin bypass allowed), install deps, and start Node/Python/server processes in background.
â€  stop            Stop tracked background processes.
â€  status          Show git status and running pids.
â€  help            Show this help.

â€Admin notes:
â€- If you are the admin and want automatic runs without passphrase prompt:
â€  - Option A (preferred): Set ADMIN_BYPASS=1 in your shell (only on admin machine).
â€    export ADMIN_BYPASS=1
â€  - Option B: Set ADMIN_USER to your OS username (e.g., export ADMIN_USER="alice").
â€  - Option C: Use the generated .admin_key file (permissions 600); this file will be used automatically by init-encrypt and run.
â€- Non-admin users will be prompted for a passphrase to decrypt .env.enc (or will run in limited mode if decryption not done).

â€Security notes:
â€- DO NOT commit plaintext .env to the repository.
â€- Protect .env.enc and .admin_key (chmod 600).
â€- This script does NOT transmit secrets to remote servers.
â€EOF
}

â€# main dispatcher
â€if [ $# -lt 1 ]; then
â€  cmd_help
â€  exit 0
â€fi

â€case "$1" in
â€  init-encrypt) check_deps; cmd_init_encrypt;;
â€  clone) check_deps; cmd_clone_or_update;;
â€  update) check_deps; cmd_update;;
â€  run) check_deps; cmd_run;;
â€  stop) cmd_stop;;
â€  status) cmd_status;;
â€  help) cmd_help;;
â€  *) err "Unknown command: $1"; cmd_help; exit 1;;
â€esac

chmod +x sultan_setup_cli.sh
./sultan_setup_cli.sh help
export ADMIN_BYPASS=1
./sultan_setup_cli.sh init-encrypt   # Ø³ÙŠÙˆÙ„Ø¯ .admin_key ÙˆÙŠÙØ´ÙÙ‘Ø± .env Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„Ù…Ø­Ù„ÙŠ
./sultan_setup_cli.sh clone
./sultan_setup_cli.sh run
#!/usr/bin/env bash
set -euo pipefail

# ======================================================
# SULTAN-AAA QADR - All-in-one setup & run (admin bypass)
# ======================================================

# --- Configuration ---
REPO_URL="https://github.com/Abdiifahman/text-generation-webui"
TARGET_DIR="SULTAN-AAA-SYNC"
WATCH_DIR="watch_folder"
ARTIFACTS_DIR="artifacts"
ENV_ENC_FILE=".env.enc"
ENV_TEMP_FILE=".env.dec.$$"
PIDS_DIR=".pids"
LOG_DIR="logs"
ADMIN_KEY_FILE=".admin_key"
ADMIN_BYPASS="${ADMIN_BYPASS:-1}"  # Ø§ÙØªØ±Ø§Ø¶ÙŠ admin
ADMIN_USER="${ADMIN_USER:-}"

mkdir -p "$PIDS_DIR" "$LOG_DIR" "$ARTIFACTS_DIR"

info() { echo "[INFO] $*"; }
warn() { echo "[WARN] $*"; }
err() { echo "[ERROR] $*" >&2; }

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    err "Required command '$1' not found"
    exit 1
  fi
}

# --- Check dependencies ---
check_deps() {
  info "Checking dependencies..."
  require_cmd git
  require_cmd openssl
  require_cmd python3
  require_cmd pip
  require_cmd node || warn "node not found (Node features skipped)"
  require_cmd npm || warn "npm not found (Node features skipped)"
  info "Dependencies OK"
}

# --- Admin detection ---
admin_is_running() {
  if [ "$ADMIN_BYPASS" = "1" ]; then return 0; fi
  local curuser
  curuser=$(whoami 2>/dev/null || echo "")
  if [ -n "$ADMIN_USER" ] && [ "$curuser" = "$ADMIN_USER" ]; then
    return 0
  fi
  if [ -f "$ADMIN_KEY_FILE" ] && [ -r "$ADMIN_KEY_FILE" ]; then
    perms=$(stat -c "%a" "$ADMIN_KEY_FILE" 2>/dev/null || echo "")
    [[ "$perms" == "600" || "$perms" == "400" ]] && return 0
  fi
  return 1
}

# --- Init encrypt ---
cmd_init_encrypt() {
  if [ ! -f ".env" ]; then
    cat > .env <<'EOF'
OPENAI_API_KEY=your-openai-key
GEMINI_API_KEY=your-gemini-key
GROK_API_KEY=your-grok-key
GH_PAT=your-gh-pat
REPO=Abdiifahman/SULTAN-AAA-SYNC
QADR_AES_PASS=your_local_encryption_pass
EOF
    info ".env created, edit with your keys"
  fi

  if admin_is_running; then
    info "Admin detected, generating admin key if missing..."
    [ ! -f "$ADMIN_KEY_FILE" ] && openssl rand -hex 32 > "$ADMIN_KEY_FILE" && chmod 600 "$ADMIN_KEY_FILE"
    pass=$(cat "$ADMIN_KEY_FILE")
    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
    chmod 600 "$ENV_ENC_FILE"
    info ".env encrypted with admin key"
  else
    read -s -p "Enter passphrase to encrypt .env: " pass
    echo
    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
    chmod 600 "$ENV_ENC_FILE"
    info ".env encrypted"
  fi
}

# --- Decrypt env ---
decrypt_env() {
  if admin_is_running; then
    pass=$(cat "$ADMIN_KEY_FILE")
  else
    read -s -p "Enter passphrase to decrypt .env.enc: " pass
    echo
  fi
  openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass"
  chmod 600 "$ENV_TEMP_FILE"
  info ".env decrypted to temp file"
}

cleanup_env() {
  [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
}

# --- Clone/update repo ---
cmd_clone_or_update() {
  if [ -d "$TARGET_DIR/.git" ]; then
    info "Updating existing repo..."
    pushd "$TARGET_DIR" >/dev/null
    git fetch --all --prune
    git reset --hard origin/main || git reset --hard origin/HEAD
    git clean -fd
    popd >/dev/null
  else
    info "Cloning repo..."
    git clone --depth 1 "$REPO_URL" "$TARGET_DIR"
  fi
}

# --- Run Node/Python/server ---
cmd_run() {
  _trap_cleanup() { cleanup_env; }
  trap _trap_cleanup EXIT INT TERM

  cmd_clone_or_update
  decrypt_env

  # Load env
  set -o allexport; source "$ENV_TEMP_FILE"; set +o allexport

  # Python venv
  [ ! -d "venv" ] && python3 -m venv venv
  . venv/bin/activate
  pip install --upgrade pip >/dev/null
  [ -f "requirements.txt" ] && pip install -r requirements.txt

  # Node deps
  [ -f "package.json" ] && command -v npm >/dev/null && npm install --silent

  # Start Node
  [ -f "script.js" ] && command -v node >/dev/null && \
    nohup node script.js inputs.txt "ØªØ­Ù„ÙŠÙ„" > "$LOG_DIR/node.log" 2>&1 & echo $! > "$PIDS_DIR/node.pid"

  # Start Python agent
  [ -f "agent.py" ] && command -v python3 >/dev/null && \
    nohup python3 agent.py > "$LOG_DIR/agent.log" 2>&1 & echo $! > "$PIDS_DIR/agent.pid"

  # Optional server.py
  [ -f "server.py" ] && nohup python3 server.py --portable --api > "$LOG_DIR/server.log" 2>&1 & echo $! > "$PIDS_DIR/server.pid"

  info "All processes started (Node/Python/server). Use './$0 status' or './$0 stop'"
}

# --- Show status ---
cmd_status() {
  echo "=== Repo status ==="
  [ -d "$TARGET_DIR/.git" ] && pushd "$TARGET_DIR" >/dev/null && git status --short --branch && popd >/dev/null
  echo "=== Processes ==="
  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
    [ -f "$f" ] || continue
    pid=$(cat "$f")
    kill -0 "$pid" 2>/dev/null && echo "$(basename "$f" .pid): running ($pid)" || echo "$(basename "$f" .pid): not running"
  done
}

# --- Stop processes ---
cmd_stop() {
  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
    [ -f "$f" ] || continue
    pid=$(cat "$f")
    kill "$pid" 2>/dev/null || true
    rm -f "$f"
  done
  info "All tracked processes stopped."
}

# --- Help ---
cmd_help() {
  cat <<'EOF'
SULTAN-AAA QADR CLI

Usage: ./sultan_setup_cli.sh <command>

Commands:
  init-encrypt    Create .env (if missing) and encrypt (.env.enc)
  clone           Clone or update repository
  run             Start Node/Python/server (admin bypass allowed)
  stop            Stop all tracked processes
  status          Show repo & process status
  help            Show this help
EOF
}

# --- Dispatcher ---
check_deps
case "${1:-}" in
  init-encrypt) cmd_init_encrypt ;;
  clone) cmd_clone_or_update ;;
  run) cmd_run ;;
  stop) cmd_stop ;;
  status) cmd_status ;;
  help|"" ) cmd_help ;;
  *) err "Unknown command: $1"; cmd_help ;;
esac
# Python
__pycache__/
*.pyc
env/
venv/
.env

# Logs, editor backups
*.log
*.swp
.DS_Store

# Local output
body.html
headers.txt
analysis_report.json
MIT License

Copyright (c) 2025 <Your Name>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, subject to the following conditions:
...
(standard MIT text)
# QADR CLI â€” Repository (Organized)

**Ù‡Ø¯Ù Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:** Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ø¯ÙˆØ§Øª ÙˆØ§Ø¬Ù‡Ø© Ø³Ø·Ø± Ø£ÙˆØ§Ù…Ø± Ù„ØªØ±ØªÙŠØ¨ØŒ ØªØ­Ù„ÙŠÙ„ Ùˆ ØªÙˆØ«ÙŠÙ‚ ØªÙØ§Ø¹Ù„Ø§Øª ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„ÙˆÙŠØ¨ Ù„Ù„Ø£Ø¬Ù‡Ø²Ø© (Ù…Ø«Ù„ ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ø±Ø§ÙˆØªØ±).  
**Ù…Ø¨Ø¯Ø£ Ø§Ù„Ø¹Ù…Ù„:** Ø£Ø¯ÙˆØ§Øª **ØªØ´Ø®ÙŠØµ ÙˆØªØ­Ù„ÙŠÙ„** ÙÙ‚Ø· â€” ØªØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙˆÙ„Ø§ ØªÙ†ÙØ° Ù‡Ø¬Ù…Ø§Øª. ÙŠØ¬Ø¨ ØªØ´ØºÙŠÙ„Ù‡Ø§ ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø£Ø¬Ù‡Ø²Ø© ØªÙ…Ù„ÙƒÙ‡Ø§ Ø£Ùˆ Ù„Ø¯ÙŠÙƒ Ø¥Ø°Ù† ØµØ±ÙŠØ­ Ù„Ø§Ø®ØªØ¨Ø§Ø±Ù‡Ø§.

## ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©
- Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø¶Ø¯ Ø£Ø¬Ù‡Ø²Ø© Ø£Ùˆ Ø´Ø¨ÙƒØ§Øª Ø¯ÙˆÙ† Ø¥Ø°Ù† ØµØ±ÙŠØ­.
- Ø£ÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØºÙŠØ± Ù‚Ø§Ù†ÙˆÙ†ÙŠ ÙŠÙ‚Ø¹ Ø¹Ù„Ù‰ Ø¹Ø§ØªÙ‚ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….

## Ù…Ø§ ÙŠØªØ¶Ù…Ù†Ù‡ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹
- `qadr/` Ø­Ø²Ù…Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† ØªØ­ÙˆÙŠ CLI ÙˆÙ…ÙˆØ¯ÙŠÙ„Ø§Øª ØªØ­Ù„ÙŠÙ„
- Ø³ÙƒØ±Ø¨Øª `git-optional-commit.sh` Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ù…Ù„ÙŠØ§Øª Git
- Ø£Ù…Ø«Ù„Ø© Ø¢Ù…Ù†Ø© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø­Ù„ÙŠ

## Ø£ÙˆÙ„ÙŠÙ‘Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„ (Ù…Ø­Ù„ÙŠ)
1. Ø§Ù†Ø³Ø® Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹:
```bash
git clone <repo-url>
cd qadr-cli
python3 -m venv env
source env/bin/activate
pip install -r requirements.txt  # Ø¥Ù† ÙˆÙØ¬Ø¯
bash examples/safe_demo_localhost.sh
---

### `CONTRIBUTING.md`
```md
# Contributing

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø±ØºØ¨ØªÙƒ Ø¨Ø§Ù„Ù…Ø³Ø§Ù‡Ù…Ø©. Ø§Ù„ØªØ²Ø§Ù…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©:
- ÙƒÙ„ PR ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù‘Ù† ÙˆØµÙ Ø§Ù„ØªØºÙŠÙ‘Ø±Ø§Øª ÙˆØ³Ø¨Ø¨Ù‡Ø§.
- Ù„Ø§ ØªØ¶ÙŠÙ Ø£ÙŠ ÙƒÙˆØ¯ Ù‚Ø¯ ÙŠØ³Ù…Ø­ Ø¨Ø§Ø³ØªØºÙ„Ø§Ù„ Ø£Ø¬Ù‡Ø²Ø© Ø·Ø±Ù Ø«Ø§Ù„Ø«.
- Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ø£ÙŠÙ‘ Ù…ÙŠØ²Ø© ØªÙ…Ø³Ù‘ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒÙŠ.
#!/usr/bin/env bash
# git-optional-commit.sh
# Utility to stage/commit/push with a few convenient flags.
# Usage examples are provided in README.

set -e

ARGS=()
AMEND=false
NO_COMMIT=false
PUSH=false
MESSAGE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -a|--all)
      DO_ALL=true
      shift
      ;;
    --no-commit)
      NO_COMMIT=true; shift
      ;;
    --amend)
      AMEND=true; shift
      ;;
    -m)
      MESSAGE="$2"; shift 2
      ;;
    --push)
      PUSH=true; shift
      ;;
    -h|--help)
      echo "Usage: $0 -a [-m \"msg\"] [--no-commit] [--amend] [--push]"; exit 0
      ;;
    *)
      ARGS+=("$1"); shift
      ;;
  esac
done

if [ "${DO_ALL}" = true ]; then
  git add -A
fi

if [ "${NO_COMMIT}" = true ]; then
  echo "Staged changes but not committing (as requested)."
  exit 0
fi

if [ -z "$MESSAGE" ] && [ "$AMEND" = false ]; then
  echo "No commit message supplied. Use -m \"message\"."
  exit 1
fi

if [ "$AMEND" = true ]; then
  if git rev-parse --verify HEAD >/dev/null 2>&1; then
    if [ -n "$MESSAGE" ]; then
      git commit --amend -m "$MESSAGE"
    else
      git commit --amend --no-edit
    fi
  else
    echo "No existing commit to amend. Creating first commit instead."
    git commit -m "${MESSAGE:-'Initial commit'}"
  fi
else
  git commit -m "$MESSAGE"
fi

if [ "$PUSH" = true ]; then
  git push
fi
"""QADR â€” defensive CLI toolkit skeleton"""
__version__ = "0.1.0"
#!/usr/bin/env python3
import argparse
from qadr.scanner import safe_fetch_report

def main():
    parser = argparse.ArgumentParser(prog="qadr", description="QADR CLI (defensive-only toolkit)")
    parser.add_argument("target", help="Target URL or IP (must be authorized)")
    parser.add_argument("--out", help="Output file prefix", default="qadr_report")
    args = parser.parse_args()

    # Safety check (explicit confirmation)
    print("Warning: run only against systems you own or have permission to test.")
    confirm = input(f"Type 'I-OWN-OR-HAVE-PERMISSION' to proceed against {args.target}: ")
    if confirm.strip() != "I-OWN-OR-HAVE-PERMISSION":
        print("Confirmation not provided. Aborting.")
        return

    safe_fetch_report(args.target, args.out)

if __name__ == "__main__":
    main()
   git init
git add -A
git commit -m "Initial skeleton for qadr-cli (defensive toolkit)"
git branch -M main
git remote add origin git@github.com:USERNAME/qadr-cli.git   # Ø£Ùˆ https URL
git push -u origin main
qadr paste-intel --ipfs QmXyz...
qadr swarm --watch keywords="password,api_key"
qadr-geo.js
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { program } = require('commander');
const geoip = require('geoip-lite');
const express = require('express');
const open = require('open');

program
  .name('qadr-geo')
  .description('Extract IPs/domains/emails from file or stdin, GeoIP enrich, export GeoJSON, serve map')
  .option('-f, --file <path>', 'input file (text)')
  .option('-i, --ip <ip>', 'single IP to resolve')
  .option('-o, --out <path>', 'output GeoJSON file', 'geo.json')
  .option('-m, --map', 'serve map on http://127.0.0.1:3000 and open browser')
  .option('--port <n>', 'map server port', 3000)
  .parse(process.argv);

const opts = program.opts();

const IP_REGEX = /\b(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\b/g;
const EMAIL_REGEX = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi;
const DOMAIN_REGEX = /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi;

function readInput() {
  if (opts.ip) return opts.ip;
  if (opts.file) {
    const p = path.resolve(opts.file);
    if (!fs.existsSync(p)) {
      console.error('[!] input file not found:', p);
      process.exit(1);
    }
    return fs.readFileSync(p, 'utf8');
  }
  // stdin fallback (pipe)
  const stat = fs.fstatSync(0);
  if (stat.isFIFO() || stat.isFile()) {
    return fs.readFileSync(0, 'utf8');
  }
  console.error('[!] No input provided. Use --file or pipe data or --ip');
  process.exit(1);
}

function extractIndicators(text) {
  const ips = Array.from(new Set((text.match(IP_REGEX) || []).map(s => s.trim())));
  const emails = Array.from(new Set((text.match(EMAIL_REGEX) || []).map(s => s.trim())));
  const domains = Array.from(new Set((text.match(DOMAIN_REGEX) || []).map(s => s.trim()).filter(d => !/^\d+\./.test(d))));
  return { ips, emails, domains };
}

function enrichIPs(ips) {
  const features = [];
  for (const ip of ips) {
    const info = geoip.lookup(ip);
    if (info && info.ll) {
      const [lat, lon] = info.ll;
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [lon, lat] },
        properties: {
          ip,
          country: info.country || null,
          region: info.region || null,
          city: info.city || null,
          range: info.range ? `${info.range}` : null,
          source: 'geoip-lite',
          ts: new Date().toISOString()
        }
      });
    } else {
      // Unknown location -> place as null-point (optional)
      features.push({
        type: 'Feature',
        geometry: null,
        properties: {
          ip,
          country: null,
          note: 'no-geo',
          source: 'geoip-lite',
          ts: new Date().toISOString()
        }
      });
    }
  }
  return features;
}

(async () => {
  try {
    const text = readInput();
    const inds = extractIndicators(text);
    console.log(`[+] Extracted: ${inds.ips.length} IP(s), ${inds.domains.length} domain(s), ${inds.emails.length} email(s)`);

    const ipFeatures = enrichIPs(inds.ips);
    // Add domain/email as properties only (optionally geocode domains via DNS/WHOIS externally)
    const otherFeatures = [];
    for (const d of inds.domains) {
      otherFeatures.push({
        type: 'Feature',
        geometry: null,
        properties: { domain: d, type: 'domain', ts: new Date().toISOString() }
      });
    }
    for (const e of inds.emails) {
      otherFeatures.push({
        type: 'Feature',
        geometry: null,
        properties: { email: e, type: 'email', ts: new Date().toISOString() }
      });
    }

    const featureCollection = {
      type: 'FeatureCollection',
      features: [...ipFeatures, ...otherFeatures]
    };

    fs.writeFileSync(opts.out, JSON.stringify(featureCollection, null, 2));
    console.log(`[+] Wrote GeoJSON â†’ ${opts.out}`);

    if (opts.map) {
      const port = parseInt(opts.port, 10) || 3000;
      const app = express();
      const root = path.join(__dirname, '.qadr_map_static');
      if (!fs.existsSync(root)) fs.mkdirSync(root, { recursive: true });
      // write map.html into static folder
      const mapHtmlPath = path.join(root, 'map.html');
      const mapTemplate = fs.readFileSync(path.join(__dirname, 'map.html'), 'utf8');
      fs.writeFileSync(mapHtmlPath, mapTemplate);

      // serve static and geojson
      app.use(express.static(root));
      app.get('/data/geo.json', (req, res) => {
        res.type('application/json').send(JSON.stringify(featureCollection));
      });

      const server = app.listen(port, '127.0.0.1', () => {
        const url = `http://127.0.0.1:${port}/map.html`;
        console.log(`[+] Map server running: ${url}`);
        (async () => {
          try { await open(url); } catch (e) { /* ignore */ }
        })();
      });

      // graceful shutdown on SIGINT
      process.on('SIGINT', () => {
        server.close(() => {
          console.log('\n[+] server stopped');
          process.exit(0);
        });
      });
    }
  } catch (err) {
    console.error('[!] Error:', err.message || err);
    process.exit(1);
  }
})();
package.json
{
  "name": "qadr-geo-cli",
  "version": "0.1.0",
  "description": "QADR-GEO lightweight CLI: extract indicators, geoip, export GeoJSON, serve a map",
  "main": "qadr-geo.js",
  "bin": {
    "qadr-geo": "./qadr-geo.js"
  },
  "scripts": {
    "start": "node qadr-geo.js"
  },
  "dependencies": {
    "commander": "^11.0.0",
    "express": "^4.18.2",
    "geoip-lite": "^1.4.2",
    "open": "^9.0.0"
  }
}
npm install
chmod +x qadr-geo.js
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QADR GEO - Map</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  html,body,#map { height: 100%; margin: 0; padding: 0; }
  .legend { background: white; padding: 6px; border-radius:4px; }
</style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
async function init() {
  const map = L.map('map').setView([20,0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom: 19 }).addTo(map);

  const res = await fetch('/data/geo.json');
  const geo = await res.json();

  function pointToLayer(feature, latlng) {
    return L.circleMarker(latlng, { radius:6, weight:1, fillOpacity:0.9 });
  }

  const markers = L.geoJSON(geo, {
    pointToLayer,
    filter: f => !!f.geometry && f.geometry.type === 'Point',
    onEachFeature: (f, layer) => {
      const p = f.properties || {};
      let html = '<b>QADR Event</b><br/>';
      if (p.ip) html += `IP: ${p.ip}<br/>`;
      if (p.country) html += `Country: ${p.country}<br/>`;
      if (p.city) html += `City: ${p.city}<br/>`;
      if (p.domain) html += `Domain: ${p.domain}<br/>`;
      if (p.email) html += `Email: ${p.email}<br/>`;
      html += `Time: ${p.ts || ''}`;
      layer.bindPopup(html);
    }
  }).addTo(map);

  // Fit to markers if any
  const has = geo.features.filter(f => f.geometry && f.geometry.type === 'Point');
  if (has.length) {
    const group = L.featureGroup(has.map(f => L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]])));
    map.fitBounds(group.getBounds().pad(0.2));
  }
}
init().catch(err => {
  document.body.innerHTML = '<pre>Error loading map: '+err+'</pre>';
});
</script>
</body>
</html>
git init
git add .
git commit -m "Initial commit: Qadr safe passive audit plugin v1.0"
git branch -M main
git remote add origin git@github.com:yourusername/qadr_passive_audit.git
git push -u origin main
