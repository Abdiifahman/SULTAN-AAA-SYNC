LICENSE (Apache-2.0)
#!/bin/bash
qadr-cli/
├─ .gitignore
├─ LICENSE
├─ README.md
├─ CONTRIBUTING.md
├─ CODE_OF_CONDUCT.md
├─ git-optional-commit.sh
├─ setup.sh
├─ docs/
│  └─ architecture.md
├─ examples/
│  └─ safe_demo_localhost.sh
├─ qadr/
│  ├─ __init__.py
│  ├─ cli.py-qadr-
---geo-cli
│  ├─ scanner.py        # مُهيأ ليعمل فقط مع أهداف مُصرّح بها
│  ├─ reporters.py
│  └─ utils.py
└─ tests/
   └─ test_scan_safety.py
# Agent in your Git: Automatic setup for SULTAN-AAA-QADR with text-generation-webui, APIs, install, error check, run super code.

set -e  # Exit on error

echo "Cloning text-generation-webui..."
git clone https://github.com/Abdiifahman/text-generation-webui SULTAN-AAA-SYNC || { echo "Clone failed"; exit 1; }
cd SULTAN-AAA-SYNC

echo "Creating files..."
mkdir -p .github/workflows watch_folder .devcontainer
./git-optional-commit.sh -a --samend -m "Amended message" --push

./git-optional-commit.sh -a --no-commit
# script.js (with confirmed Grok API: https://api.x.ai/v1/chat/completions, Bearer auth)
cat << 'EOF' > script.js
const crypto = require('crypto');
const OpenAI = require('openai');
const fs = require('fs').promises;
require('dotenv').config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function grokAnalyze(content) {
  const url = "https://api.x.ai/v1/chat/completions";
  const headers = { "Authorization": `Bearer ${process.env.GROK_API_KEY}`, "Content-Type": "application/json" };
  const data = {
    model: "grok-beta",
    messages: [{ role: "user", content: `Analyze: ${content}` }],
    temperature: 0.2,
    max_tokens: 400
  };
  try {
    const response = await fetch(url, { method: "POST", headers, body: JSON.stringify(data) });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const result = await response.json();
    return result.choices[0].message.content;
  } catch (err) {
    console.error(`Grok error: ${err.message}`);
    return "Fallback: Grok unreachable";
  }
}

function generateOpenAIStyleId(prefix = 'sess') {
  const timestamp = Date.now().toString(36);
  const randomPart = crypto.randomBytes(12).toString('hex');
  return `${prefix}-${timestamp}-${randomPart}`;
}

async function aiAnalysis(report, userInput = 'استخرج الكل') {
  const prompt = `Analyze report: ${JSON.stringify(report, null, 2)}. Intent: ${userInput}. JSON: {"suggestions": [], "code_changes": [{"section": "", "change": ""}]} `;
  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      max_tokens: 400
    });
    return JSON.parse(completion.choices[0].message.content) || { suggestions: [], code_changes: [] };
  } catch (err) {
    console.error(`OpenAI error: ${err.message}`);
    return { suggestions: ['Fallback'], code_changes: [] };
  }
}

async function loadReport(filePath = 'inputs.txt') {
  try { return JSON.parse(await fs.readFile(filePath, 'utf-8')); } catch { return { error: 'Invalid' }; }
}

async function main() {
  const id = generateOpenAIStyleId('sandbox');
  console.log(`[APP] ID: ${id}`);
  const args = process.argv.slice(2);
  const report = await loadReport(args[0]);
  if (report.error) { console.error(report.error); return; }
  const result = await aiAnalysis(report, args[1] || 'تحليل');
  const grokRes = await grokAnalyze(JSON.stringify(report));
  console.log(`Result: ${JSON.stringify(result, null, 2)}\nGrok: ${grokRes}`);
}

if (require.main === module) main();
EOF

# agent.py (Python with Gemini/Grok)
cat << 'EOF' > agent.py
#!/usr/bin/env python3
import os, subprocess, time, base64, json, requests
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()

GH_PAT = os.getenv("GH_PAT")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GROK_API_KEY = os.getenv("GROK_API_KEY")
REPO = os.getenv("REPO", "Abdiifahman/SULTAN-AAA-SYNC")
WATCH_DIR = "./watch_folder"

def decode_base64(encoded_str):
  try:
    return base64.b64decode(encoded_str).decode('utf-8')
  except Exception as e:
    print(f"Base64 error: {e}")
    return None

def analyze_with_gemini(content):
  if not GEMINI_API_KEY: return print("Gemini key missing.")
  url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
  data = {"contents": [{"parts": [{"text": f"Analyze: {content}"}]}]}
  try:
    r = requests.post(url, json=data, params={"key": GEMINI_API_KEY})
    r.raise_for_status()
    print(f"Gemini: {r.json()['candidates'][0]['content']['parts'][0]['text']}")
  except Exception as e:
    print(f"Gemini error: {e}")

def analyze_with_grok(content):
  if not GROK_API_KEY: return print("Grok key missing. Get from https://x.ai/api")
  url = "https://api.x.ai/v1/chat/completions"
  headers = {"Authorization": f"Bearer {GROK_API_KEY}", "Content-Type": "application/json"}
  data = {
    "model": "grok-beta",
    "messages": [{"role": "user", "content": f"Analyze: {content}"}],
    "temperature": 0.2,
    "max_tokens": 400
  }
  try:
    r = requests.post(url, headers=headers, json=data)
    r.raise_for_status()
    print(f"Grok: {r.json()['choices'][0]['message']['content']}")
  except Exception as e:
    print(f"Grok error: {e}")

def process_file(file_path):
  content = file_path.read_text()
  decoded = decode_base64(content)
  if decoded:
    analyze_with_gemini(decoded)
    analyze_with_grok(decoded)

def watch_directory():
  Path(WATCH_DIR).mkdir(exist_ok=True)
  print(f"Watching: {WATCH_DIR}")
  known_files = {}
  while True:
    for file_path in Path(WATCH_DIR).glob("*"):
      mtime = file_path.stat().st_mtime
      if file_path.name not in known_files or known_files[file_path.name] != mtime:
        print(f"Change in {file_path}")
        known_files[file_path.name] = mtime
        process_file(file_path)
    time.sleep(5)

def main():
  if not all([GH_PAT, GEMINI_API_KEY, GROK_API_KEY]):
    print("Update .env with keys (Grok from https://x.ai/api).")
    return
  watch_directory()

if __name__ == "__main__": main()
EOF

# package.json
cat << EOF > package.json
{"name": "sultan-aaa-sync", "version": "1.0.0", "main": "script.js", "scripts": {"start": "node script.js"}, "dependencies": {"openai": "^4.0.0", "dotenv": "^16.0.0"}}
EOF

# requirements.txt
cat << EOF > requirements.txt
requests==2.31.0
python-dotenv==1.0.0
EOF

# .env
cat << EOF > .env
OPENAI_API_KEY=your-openai-key
GH_PAT=your-gh-pat
GEMINI_API_KEY=your-gemini-key
GROK_API_KEY=your-grok-key  # From https://x.ai/api
REPO=Abdiifahman/SULTAN-AAA-SYNC
NGROK_AUTH_TOKEN=dxoom18@gmail.com:Aaa11223344@1
EOF

# .gitignore
cat << EOF > .gitignore
node_modules/
.env
watch_folder/
__pycache__/
installer_files/
venv/
EOF

# ci.yml
cat << 'EOF' > .github/workflows/ci.yml
name: CI
on: [push, pull_request, workflow_dispatch]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm install
      - run: node script.js inputs.txt "تحليل"
        env: { OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}, GROK_API_KEY: ${{ secrets.GROK_API_KEY }} }
      - uses: actions/setup-python@v4
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: python agent.py
        env: { GH_PAT: ${{ secrets.GH_PAT }}, GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}, GROK_API_KEY: ${{ secrets.GROK_API_KEY }} }
EOF

# inputs.txt
echo '{"data": "Super code test"}' > inputs.txt

# Install deps & check errors
echo "Installing..."
npm install || { echo "NPM error"; exit 1; }
pip install -r requirements.txt || { echo "Pip error"; exit 1; }

# Run super code
echo "Running super code..."
node script.js inputs.txt "تحليل" &
python agent.py &
python server.py --portable --api || { echo "WebUI error"; exit 1; }

# Push
git add .
git commit -m "Auto setup super code" || true
git push origin main || { echo "Push error"; exit 1; }

echo "Setup complete. Update .env keys. Access: http://127.0.0.1:7860"
‏#!/usr/bin/env bash
‏set -euo pipefail

# ======================================================
‏# SULTAN-AAA QADR - Unified CLI (admin bypass support)
‏# - clone/update repo
‏# - encrypt/decrypt per-user .env (admin can bypass)
‏# - verify deps
‏# - run Node + Python + optional server
‏# - manage processes (start/stop/status)
#
‏# Behavior:
‏# - If you (the runner) are the admin, set ADMIN_BYPASS=1 or ADMIN_USER="your-username"
‏#   then the script will NOT prompt for passphrase and will decrypt .env.enc automatically (using a local admin-only key file).
‏# - For non-admin users, the script will ask for a passphrase to decrypt .env.enc (or skip decrypt and run in limited mode).
#
‏# Security note:
‏# - This script does NOT send keys anywhere. All secrets remain local.
‏# - Make sure .env / .env.enc are protected (chmod 600) and never commit plaintext .env.
# ======================================================

‏REPO_URL="https://github.com/Abdiifahman/text-generation-webui"
‏TARGET_DIR="SULTAN-AAA-SYNC"
‏WATCH_DIR="watch_folder"
‏ARTIFACTS_DIR="artifacts"
‏ENV_ENC_FILE=".env.enc"
‏ENV_TEMP_FILE=".env.dec.$$"   # temporary decrypted file (per-run)
‏PIDS_DIR=".pids"
‏LOG_DIR="logs"
‏ADMIN_KEY_FILE=".admin_key"   # optional local admin key file (owner-only)
‏ADMIN_USER="${ADMIN_USER:-}"  # set this env var to your admin OS username if desired
‏ADMIN_BYPASS="${ADMIN_BYPASS:-0}" # set to "1" to bypass prompts (admin only!)

‏mkdir -p "$PIDS_DIR" "$LOG_DIR" "$ARTIFACTS_DIR"

‏err() { echo "ERROR: $*" >&2; }
‏info() { echo "[INFO] $*"; }
‏warn() { echo "[WARN] $*"; }

‏require_cmd() {
‏  if ! command -v "$1" >/dev/null 2>&1; then
‏    err "Required command '$1' not found. Please install it."
‏    exit 1
‏  fi
}

‏check_deps() {
‏  info "Checking dependencies..."
‏  require_cmd git
‏  require_cmd openssl
‏  if ! command -v node >/dev/null 2>&1; then
‏    info "node not found (Node features will be skipped)"
‏  fi
‏  if ! command -v npm >/dev/null 2>&1; then
‏    info "npm not found (Node features will be skipped)"
‏  fi
‏  require_cmd python3
‏  require_cmd pip
‏  info "Dependencies check done (optional tools noted)."
}

‏# Create sample .env if missing
‏cmd_init_encrypt() {
‏  if [ -f "$ENV_ENC_FILE" ]; then
‏    info "$ENV_ENC_FILE already exists. If you want to recreate run: rm -f $ENV_ENC_FILE and re-run this command after creating .env"
‏    return
‏  fi
‏  if [ ! -f ".env" ]; then
‏    cat > .env <<'EOF'
‏# Example .env - replace values and DO NOT commit .env
‏OPENAI_API_KEY=your-openai-key
‏GEMINI_API_KEY=your-gemini-key
‏GROK_API_KEY=your-grok-key
‏GH_PAT=your-gh-pat
‏REPO=Abdiifahman/SULTAN-AAA-SYNC
‏QADR_AES_PASS=your_local_encryption_pass
‏EOF
‏    info "Created example .env. Edit it with your own keys, then run this command again to encrypt."
‏    return
‏  fi

‏  # Admin bypass? If admin and ADMIN_KEY_FILE present, encrypt with admin key automatically
‏  if admin_is_running; then
‏    info "Admin detected: encrypting .env with admin local key (no passphrase prompt)."
‏    if [ ! -f "$ADMIN_KEY_FILE" ]; then
‏      # generate admin key file (restricted)
‏      openssl rand -hex 32 > "$ADMIN_KEY_FILE"
‏      chmod 600 "$ADMIN_KEY_FILE"
‏      info "Admin key generated at $ADMIN_KEY_FILE (permissions 600). Protect this file."
‏    fi
‏    pass=$(cat "$ADMIN_KEY_FILE")
‏    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
‏    chmod 600 "$ENV_ENC_FILE"
‏    info "Encrypted .env saved to $ENV_ENC_FILE (admin key used). Remove plaintext .env if present."
‏    return
‏  fi

‏  # Non-admin flow: ask for passphrase to encrypt
‏  read -s -p "Choose a passphrase to encrypt your .env (you will need it to run): " pass
‏  echo
‏  if [ -z "$pass" ]; then err "Empty passphrase not allowed."; exit 1; fi
‏  openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
‏  chmod 600 "$ENV_ENC_FILE"
‏  info "Encrypted .env saved to $ENV_ENC_FILE. Remove plaintext .env if present."
}

‏# admin detection function
‏admin_is_running() {
‏  # Order of checks:
‏  # 1) If ADMIN_BYPASS=1 set in env, treat as admin (use only on admin machine)
‏  # 2) If ADMIN_USER is set and matches current OS user, treat as admin
‏  # 3) If ADMIN_KEY_FILE exists and readable by current user, treat as admin
‏  # Important: Do not use ADMIN_BYPASS on multi-user systems unless you trust environment security
‏  if [ "${ADMIN_BYPASS:-0}" = "1" ]; then
‏    return 0
‏  fi
‏  local curuser
‏  curuser=$(whoami 2>/dev/null || echo "")
‏  if [ -n "$ADMIN_USER" ] && [ "$curuser" = "$ADMIN_USER" ]; then
‏    return 0
‏  fi
‏  if [ -f "$ADMIN_KEY_FILE" ] && [ -r "$ADMIN_KEY_FILE" ]; then
‏    # ensure only owner can read it
‏    perms=$(stat -c "%a" "$ADMIN_KEY_FILE" 2>/dev/null || echo "")
‏    # require 600 or stricter
‏    if [[ "$perms" == "600" || "$perms" == "400" || "$perms" == "600" ]]; then
‏      return 0
‏    fi
‏  fi
‏  return 1
}

‏# decrypt ENV into temp file; returns 0 on success
‏decrypt_env_prompt() {
‏  if [ ! -f "$ENV_ENC_FILE" ]; then
‏    warn "$ENV_ENC_FILE not found. Run 'init-encrypt' to create an encrypted .env from your .env file."
‏    return 1
‏  fi

‏  # Admin automatic decrypt (no prompt) if admin key present
‏  if admin_is_running; then
‏    info "Admin detected: attempting automatic decrypt using local admin key (no passphrase prompt)."
‏    if [ ! -f "$ADMIN_KEY_FILE" ]; then
‏      err "Admin key file $ADMIN_KEY_FILE missing; cannot auto-decrypt. Use init-encrypt or provide passphrase."
‏      return 1
‏    fi
‏    pass=$(cat "$ADMIN_KEY_FILE")
‏    if ! openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass" 2>/dev/null; then
‏      err "Automatic admin decryption failed (maybe admin key differs)."
‏      [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
‏      return 1
‏    fi
‏    chmod 600 "$ENV_TEMP_FILE"
‏    info "Decrypted .env to $ENV_TEMP_FILE (admin key)."
‏    return 0
‏  fi

‏  # Non-admin: prompt for passphrase
‏  read -s -p "Enter passphrase to decrypt $ENV_ENC_FILE: " pass
‏  echo
‏  if [ -z "$pass" ]; then err "Empty passphrase; abort."; return 1; fi
‏  if ! openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass" 2>/dev/null; then
‏    err "Decryption failed - wrong passphrase or corrupted file."
‏    [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
‏    return 1
‏  fi
‏  chmod 600 "$ENV_TEMP_FILE"
‏  info "Decrypted .env to $ENV_TEMP_FILE."
‏  return 0
}

‏cleanup_temp_env() {
‏  if [ -f "$ENV_TEMP_FILE" ]; then
‏    # try secure delete if shred available, otherwise delete
‏    if command -v shred >/dev/null 2>&1; then
‏      shred -u "$ENV_TEMP_FILE" 2>/dev/null || rm -f "$ENV_TEMP_FILE"
‏    else
‏      rm -f "$ENV_TEMP_FILE"
‏    fi
‏    info "Removed temporary decrypted env."
‏  fi
}

‏_safe_trap_setup() {
‏  trap cleanup_temp_env EXIT INT TERM
}

‏# clone or update repo
‏cmd_clone_or_update() {
‏  if [ -d "$TARGET_DIR/.git" ]; then
‏    info "Directory exists and is a git repo — updating..."
‏    pushd "$TARGET_DIR" > /dev/null
‏    git fetch --all --prune
‏    if git show-ref --quiet refs/remotes/origin/main; then
‏      git reset --hard origin/main
‏    else
‏      git reset --hard origin/HEAD
‏    fi
‏    git clean -fd
‏    popd > /dev/null
‏    info "Update complete."
‏  else
‏    info "Cloning ${REPO_URL} into ${TARGET_DIR}..."
‏    git clone --depth 1 "$REPO_URL" "$TARGET_DIR" || { err "Clone failed"; exit 1; }
‏    info "Clone complete."
‏  fi
}

‏# show status
‏cmd_status() {
‏  echo "=== Repo status ==="
‏  if [ -d "$TARGET_DIR/.git" ]; then
‏    pushd "$TARGET_DIR" >/dev/null
‏    git status --short --branch
‏    popd >/dev/null
‏  else
‏    echo "Repository not present."
‏  fi
‏  echo "=== Processes ==="
‏  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
‏    [ -f "$f" ] || continue
‏    pid=$(cat "$f")
‏    if kill -0 "$pid" 2>/dev/null; then
‏      echo "$(basename "$f" .pid): running (pid $pid)"
‏    else
‏      echo "$(basename "$f" .pid): not running (stale pid file)"
‏    fi
‏  done
}

‏# stop processes
‏cmd_stop() {
‏  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
‏    [ -f "$f" ] || continue
‏    pid=$(cat "$f")
‏    if kill -0 "$pid" 2>/dev/null; then
‏      info "Stopping pid $pid..."
‏      kill "$pid"
‏      sleep 1
‏      if kill -0 "$pid" 2>/dev/null; then
‏        warn "Process $pid did not stop, forcing..."
‏        kill -9 "$pid" || true
‏      fi
‏    fi
‏    rm -f "$f"
‏  done
‏  info "All tracked processes stopped."
}

‏# run services: node script.js, python agent.py, optional server.py
‏cmd_run() {
‏  _safe_trap_setup

‏  # ensure repo present
‏  cmd_clone_or_update

‏  # decrypt env (admin bypass if admin)
‏  if ! decrypt_env_prompt; then
‏    err "Cannot continue without decrypted environment."
‏    exit 2
‏  fi

‏  # load env into this shell (but avoid exporting secrets to logs)
‏  set -o allexport
‏  # shellcheck disable=SC1091
‏  source "$ENV_TEMP_FILE"
‏  set +o allexport

‏  # python venv & deps
‏  if [ ! -d "venv" ]; then
‏    python3 -m venv venv || true
‏  fi
‏  # shellcheck disable=SC1091
‏  . venv/bin/activate
‏  pip install --upgrade pip >/dev/null
‏  if [ -f "requirements.txt" ]; then
‏    pip install -r requirements.txt
‏  fi

‏  # node deps
‏  if [ -f "package.json" ] && command -v npm >/dev/null 2>&1; then
‏    npm install --silent || info "npm install returned non-zero"
‏  fi

‏  # start node (if exists)
‏  if [ -f "script.js" ] && command -v node >/dev/null 2>&1; then
‏    info "Starting Node script (script.js)..."
‏    nohup node script.js inputs.txt "تحليل" > "$LOG_DIR/node.log" 2>&1 &
‏    echo $! > "$PIDS_DIR/node.pid"
‏    info "Node started (pid $(cat $PIDS_DIR/node.pid))."
‏  else
‏    info "No script.js or Node not available; skipping Node process."
‏  fi

‏  # start python agent
‏  if [ -f "agent.py" ] && command -v python3 >/dev/null 2>&1; then
‏    info "Starting Python agent (agent.py)..."
‏    nohup python3 agent.py > "$LOG_DIR/agent.log" 2>&1 &
‏    echo $! > "$PIDS_DIR/agent.pid"
‏    info "Python agent started (pid $(cat $PIDS_DIR/agent.pid))."
‏  else
‏    info "No agent.py or Python not available; skipping Python agent."
‏  fi

‏  # optional server.py
‏  if [ -f "server.py" ]; then
‏    info "Starting optional server.py..."
‏    nohup python3 server.py --portable --api > "$LOG_DIR/server.log" 2>&1 &
‏    echo $! > "$PIDS_DIR/server.pid"
‏    info "server.py started (pid $(cat $PIDS_DIR/server.pid))."
‏  else
‏    info "server.py not found; skipping server start."
‏  fi

‏  info "All requested processes have been started. Use './$0 status' to check, './$0 stop' to stop."
‏  # cleanup will be done via trap on exit if script ends
}

‏# alias update
‏cmd_update() { cmd_clone_or_update; }

‏# help
‏cmd_help() {
‏  cat <<'EOF'
‏SULTAN-AAA QADR CLI (admin-bypass capable)

‏Usage:
‏  ./sultan_setup_cli.sh <command>

‏Commands:
‏  init-encrypt    Create .env (if missing) and encrypt it into .env.enc (per-user or admin key).
‏                  - Admin automatic flow: set ADMIN_BYPASS=1 or ADMIN_USER to match your OS username.
‏                  - Admin key file: .admin_key (auto-generated on init for admin).
‏  clone           Clone or update the repository (idempotent).
‏  update          Alias for clone (fetch & reset).
‏  run             Decrypt .env.enc (admin bypass allowed), install deps, and start Node/Python/server processes in background.
‏  stop            Stop tracked background processes.
‏  status          Show git status and running pids.
‏  help            Show this help.

‏Admin notes:
‏- If you are the admin and want automatic runs without passphrase prompt:
‏  - Option A (preferred): Set ADMIN_BYPASS=1 in your shell (only on admin machine).
‏    export ADMIN_BYPASS=1
‏  - Option B: Set ADMIN_USER to your OS username (e.g., export ADMIN_USER="alice").
‏  - Option C: Use the generated .admin_key file (permissions 600); this file will be used automatically by init-encrypt and run.
‏- Non-admin users will be prompted for a passphrase to decrypt .env.enc (or will run in limited mode if decryption not done).

‏Security notes:
‏- DO NOT commit plaintext .env to the repository.
‏- Protect .env.enc and .admin_key (chmod 600).
‏- This script does NOT transmit secrets to remote servers.
‏EOF
}

‏# main dispatcher
‏if [ $# -lt 1 ]; then
‏  cmd_help
‏  exit 0
‏fi

‏case "$1" in
‏  init-encrypt) check_deps; cmd_init_encrypt;;
‏  clone) check_deps; cmd_clone_or_update;;
‏  update) check_deps; cmd_update;;
‏  run) check_deps; cmd_run;;
‏  stop) cmd_stop;;
‏  status) cmd_status;;
‏  help) cmd_help;;
‏  *) err "Unknown command: $1"; cmd_help; exit 1;;
‏esac

chmod +x sultan_setup_cli.sh
./sultan_setup_cli.sh help
export ADMIN_BYPASS=1
./sultan_setup_cli.sh init-encrypt   # سيولد .admin_key ويُشفّر .env باستخدام المفتاح المحلي
./sultan_setup_cli.sh clone
./sultan_setup_cli.sh run
#!/usr/bin/env bash
set -euo pipefail

# ======================================================
# SULTAN-AAA QADR - All-in-one setup & run (admin bypass)
# ======================================================

# --- Configuration ---
REPO_URL="https://github.com/Abdiifahman/text-generation-webui"
TARGET_DIR="SULTAN-AAA-SYNC"
WATCH_DIR="watch_folder"
ARTIFACTS_DIR="artifacts"
ENV_ENC_FILE=".env.enc"
ENV_TEMP_FILE=".env.dec.$$"
PIDS_DIR=".pids"
LOG_DIR="logs"
ADMIN_KEY_FILE=".admin_key"
ADMIN_BYPASS="${ADMIN_BYPASS:-1}"  # افتراضي admin
ADMIN_USER="${ADMIN_USER:-}"

mkdir -p "$PIDS_DIR" "$LOG_DIR" "$ARTIFACTS_DIR"

info() { echo "[INFO] $*"; }
warn() { echo "[WARN] $*"; }
err() { echo "[ERROR] $*" >&2; }

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    err "Required command '$1' not found"
    exit 1
  fi
}

# --- Check dependencies ---
check_deps() {
  info "Checking dependencies..."
  require_cmd git
  require_cmd openssl
  require_cmd python3
  require_cmd pip
  require_cmd node || warn "node not found (Node features skipped)"
  require_cmd npm || warn "npm not found (Node features skipped)"
  info "Dependencies OK"
}

# --- Admin detection ---
admin_is_running() {
  if [ "$ADMIN_BYPASS" = "1" ]; then return 0; fi
  local curuser
  curuser=$(whoami 2>/dev/null || echo "")
  if [ -n "$ADMIN_USER" ] && [ "$curuser" = "$ADMIN_USER" ]; then
    return 0
  fi
  if [ -f "$ADMIN_KEY_FILE" ] && [ -r "$ADMIN_KEY_FILE" ]; then
    perms=$(stat -c "%a" "$ADMIN_KEY_FILE" 2>/dev/null || echo "")
    [[ "$perms" == "600" || "$perms" == "400" ]] && return 0
  fi
  return 1
}

# --- Init encrypt ---
cmd_init_encrypt() {
  if [ ! -f ".env" ]; then
    cat > .env <<'EOF'
OPENAI_API_KEY=your-openai-key
GEMINI_API_KEY=your-gemini-key
GROK_API_KEY=your-grok-key
GH_PAT=your-gh-pat
REPO=Abdiifahman/SULTAN-AAA-SYNC
QADR_AES_PASS=your_local_encryption_pass
EOF
    info ".env created, edit with your keys"
  fi

  if admin_is_running; then
    info "Admin detected, generating admin key if missing..."
    [ ! -f "$ADMIN_KEY_FILE" ] && openssl rand -hex 32 > "$ADMIN_KEY_FILE" && chmod 600 "$ADMIN_KEY_FILE"
    pass=$(cat "$ADMIN_KEY_FILE")
    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
    chmod 600 "$ENV_ENC_FILE"
    info ".env encrypted with admin key"
  else
    read -s -p "Enter passphrase to encrypt .env: " pass
    echo
    openssl enc -aes-256-cbc -pbkdf2 -iter 200000 -salt -in .env -out "$ENV_ENC_FILE" -pass pass:"$pass"
    chmod 600 "$ENV_ENC_FILE"
    info ".env encrypted"
  fi
}

# --- Decrypt env ---
decrypt_env() {
  if admin_is_running; then
    pass=$(cat "$ADMIN_KEY_FILE")
  else
    read -s -p "Enter passphrase to decrypt .env.enc: " pass
    echo
  fi
  openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ENV_ENC_FILE" -out "$ENV_TEMP_FILE" -pass pass:"$pass"
  chmod 600 "$ENV_TEMP_FILE"
  info ".env decrypted to temp file"
}

cleanup_env() {
  [ -f "$ENV_TEMP_FILE" ] && rm -f "$ENV_TEMP_FILE"
}

# --- Clone/update repo ---
cmd_clone_or_update() {
  if [ -d "$TARGET_DIR/.git" ]; then
    info "Updating existing repo..."
    pushd "$TARGET_DIR" >/dev/null
    git fetch --all --prune
    git reset --hard origin/main || git reset --hard origin/HEAD
    git clean -fd
    popd >/dev/null
  else
    info "Cloning repo..."
    git clone --depth 1 "$REPO_URL" "$TARGET_DIR"
  fi
}

# --- Run Node/Python/server ---
cmd_run() {
  _trap_cleanup() { cleanup_env; }
  trap _trap_cleanup EXIT INT TERM

  cmd_clone_or_update
  decrypt_env

  # Load env
  set -o allexport; source "$ENV_TEMP_FILE"; set +o allexport

  # Python venv
  [ ! -d "venv" ] && python3 -m venv venv
  . venv/bin/activate
  pip install --upgrade pip >/dev/null
  [ -f "requirements.txt" ] && pip install -r requirements.txt

  # Node deps
  [ -f "package.json" ] && command -v npm >/dev/null && npm install --silent

  # Start Node
  [ -f "script.js" ] && command -v node >/dev/null && \
    nohup node script.js inputs.txt "تحليل" > "$LOG_DIR/node.log" 2>&1 & echo $! > "$PIDS_DIR/node.pid"

  # Start Python agent
  [ -f "agent.py" ] && command -v python3 >/dev/null && \
    nohup python3 agent.py > "$LOG_DIR/agent.log" 2>&1 & echo $! > "$PIDS_DIR/agent.pid"

  # Optional server.py
  [ -f "server.py" ] && nohup python3 server.py --portable --api > "$LOG_DIR/server.log" 2>&1 & echo $! > "$PIDS_DIR/server.pid"

  info "All processes started (Node/Python/server). Use './$0 status' or './$0 stop'"
}

# --- Show status ---
cmd_status() {
  echo "=== Repo status ==="
  [ -d "$TARGET_DIR/.git" ] && pushd "$TARGET_DIR" >/dev/null && git status --short --branch && popd >/dev/null
  echo "=== Processes ==="
  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
    [ -f "$f" ] || continue
    pid=$(cat "$f")
    kill -0 "$pid" 2>/dev/null && echo "$(basename "$f" .pid): running ($pid)" || echo "$(basename "$f" .pid): not running"
  done
}

# --- Stop processes ---
cmd_stop() {
  for f in "$PIDS_DIR"/*.pid 2>/dev/null; do
    [ -f "$f" ] || continue
    pid=$(cat "$f")
    kill "$pid" 2>/dev/null || true
    rm -f "$f"
  done
  info "All tracked processes stopped."
}

# --- Help ---
cmd_help() {
  cat <<'EOF'
SULTAN-AAA QADR CLI

Usage: ./sultan_setup_cli.sh <command>

Commands:
  init-encrypt    Create .env (if missing) and encrypt (.env.enc)
  clone           Clone or update repository
  run             Start Node/Python/server (admin bypass allowed)
  stop            Stop all tracked processes
  status          Show repo & process status
  help            Show this help
EOF
}

# --- Dispatcher ---
check_deps
case "${1:-}" in
  init-encrypt) cmd_init_encrypt ;;
  clone) cmd_clone_or_update ;;
  run) cmd_run ;;
  stop) cmd_stop ;;
  status) cmd_status ;;
  help|"" ) cmd_help ;;
  *) err "Unknown command: $1"; cmd_help ;;
esac
# Python
__pycache__/
*.pyc
env/
venv/
.env

# Logs, editor backups
*.log
*.swp
.DS_Store

# Local output
body.html
headers.txt
analysis_report.json
MIT License

Copyright (c) 2025 <Your Name>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, subject to the following conditions:
...
(standard MIT text)
# QADR CLI — Repository (Organized)

**هدف المشروع:** مجموعة أدوات واجهة سطر أوامر لترتيب، تحليل و توثيق تفاعلات واجهات الويب للأجهزة (مثل واجهات الراوتر).  
**مبدأ العمل:** أدوات **تشخيص وتحليل** فقط — تعمل محليًا ولا تنفذ هجمات. يجب تشغيلها فقط على أجهزة تملكها أو لديك إذن صريح لاختبارها.

## تنبيهات قانونية
- لا تستخدم هذه الأدوات ضد أجهزة أو شبكات دون إذن صريح.
- أي استخدام غير قانوني يقع على عاتق المستخدم.

## ما يتضمنه المستودع
- `qadr/` حزمة بايثون تحوي CLI وموديلات تحليل
- سكربت `git-optional-commit.sh` لمساعدة عمليات Git
- أمثلة آمنة للاختبار المحلي

## أوليّات التشغيل (محلي)
1. انسخ المستودع:
```bash
git clone <repo-url>
cd qadr-cli
python3 -m venv env
source env/bin/activate
pip install -r requirements.txt  # إن وُجد
bash examples/safe_demo_localhost.sh
---

### `CONTRIBUTING.md`
```md
# Contributing

شكراً لرغبتك بالمساهمة. التزامات أساسية:
- كل PR يجب أن يتضمّن وصف التغيّرات وسببها.
- لا تضيف أي كود قد يسمح باستغلال أجهزة طرف ثالث.
- اختبارات جديدة مطلوبة لأيّ ميزة تمسّ التحليل الشبكي.
#!/usr/bin/env bash
# git-optional-commit.sh
# Utility to stage/commit/push with a few convenient flags.
# Usage examples are provided in README.

set -e

ARGS=()
AMEND=false
NO_COMMIT=false
PUSH=false
MESSAGE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -a|--all)
      DO_ALL=true
      shift
      ;;
    --no-commit)
      NO_COMMIT=true; shift
      ;;
    --amend)
      AMEND=true; shift
      ;;
    -m)
      MESSAGE="$2"; shift 2
      ;;
    --push)
      PUSH=true; shift
      ;;
    -h|--help)
      echo "Usage: $0 -a [-m \"msg\"] [--no-commit] [--amend] [--push]"; exit 0
      ;;
    *)
      ARGS+=("$1"); shift
      ;;
  esac
done

if [ "${DO_ALL}" = true ]; then
  git add -A
fi

if [ "${NO_COMMIT}" = true ]; then
  echo "Staged changes but not committing (as requested)."
  exit 0
fi

if [ -z "$MESSAGE" ] && [ "$AMEND" = false ]; then
  echo "No commit message supplied. Use -m \"message\"."
  exit 1
fi

if [ "$AMEND" = true ]; then
  if git rev-parse --verify HEAD >/dev/null 2>&1; then
    if [ -n "$MESSAGE" ]; then
      git commit --amend -m "$MESSAGE"
    else
      git commit --amend --no-edit
    fi
  else
    echo "No existing commit to amend. Creating first commit instead."
    git commit -m "${MESSAGE:-'Initial commit'}"
  fi
else
  git commit -m "$MESSAGE"
fi

if [ "$PUSH" = true ]; then
  git push
fi
"""QADR — defensive CLI toolkit skeleton"""
__version__ = "0.1.0"
#!/usr/bin/env python3
import argparse
from qadr.scanner import safe_fetch_report

def main():
    parser = argparse.ArgumentParser(prog="qadr", description="QADR CLI (defensive-only toolkit)")
    parser.add_argument("target", help="Target URL or IP (must be authorized)")
    parser.add_argument("--out", help="Output file prefix", default="qadr_report")
    args = parser.parse_args()

    # Safety check (explicit confirmation)
    print("Warning: run only against systems you own or have permission to test.")
    confirm = input(f"Type 'I-OWN-OR-HAVE-PERMISSION' to proceed against {args.target}: ")
    if confirm.strip() != "I-OWN-OR-HAVE-PERMISSION":
        print("Confirmation not provided. Aborting.")
        return

    safe_fetch_report(args.target, args.out)

if __name__ == "__main__":
    main()
   git init
git add -A
git commit -m "Initial skeleton for qadr-cli (defensive toolkit)"
git branch -M main
git remote add origin git@github.com:USERNAME/qadr-cli.git   # أو https URL
git push -u origin main
qadr paste-intel --ipfs QmXyz...
qadr swarm --watch keywords="password,api_key"
qadr-geo.js
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { program } = require('commander');
const geoip = require('geoip-lite');
const express = require('express');
const open = require('open');

program
  .name('qadr-geo')
  .description('Extract IPs/domains/emails from file or stdin, GeoIP enrich, export GeoJSON, serve map')
  .option('-f, --file <path>', 'input file (text)')
  .option('-i, --ip <ip>', 'single IP to resolve')
  .option('-o, --out <path>', 'output GeoJSON file', 'geo.json')
  .option('-m, --map', 'serve map on http://127.0.0.1:3000 and open browser')
  .option('--port <n>', 'map server port', 3000)
  .parse(process.argv);

const opts = program.opts();

const IP_REGEX = /\b(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\.(?:25[0-5]|2[0-4]\d|1?\d{1,2})\b/g;
const EMAIL_REGEX = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi;
const DOMAIN_REGEX = /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi;

function readInput() {
  if (opts.ip) return opts.ip;
  if (opts.file) {
    const p = path.resolve(opts.file);
    if (!fs.existsSync(p)) {
      console.error('[!] input file not found:', p);
      process.exit(1);
    }
    return fs.readFileSync(p, 'utf8');
  }
  // stdin fallback (pipe)
  const stat = fs.fstatSync(0);
  if (stat.isFIFO() || stat.isFile()) {
    return fs.readFileSync(0, 'utf8');
  }
  console.error('[!] No input provided. Use --file or pipe data or --ip');
  process.exit(1);
}

function extractIndicators(text) {
  const ips = Array.from(new Set((text.match(IP_REGEX) || []).map(s => s.trim())));
  const emails = Array.from(new Set((text.match(EMAIL_REGEX) || []).map(s => s.trim())));
  const domains = Array.from(new Set((text.match(DOMAIN_REGEX) || []).map(s => s.trim()).filter(d => !/^\d+\./.test(d))));
  return { ips, emails, domains };
}

function enrichIPs(ips) {
  const features = [];
  for (const ip of ips) {
    const info = geoip.lookup(ip);
    if (info && info.ll) {
      const [lat, lon] = info.ll;
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [lon, lat] },
        properties: {
          ip,
          country: info.country || null,
          region: info.region || null,
          city: info.city || null,
          range: info.range ? `${info.range}` : null,
          source: 'geoip-lite',
          ts: new Date().toISOString()
        }
      });
    } else {
      // Unknown location -> place as null-point (optional)
      features.push({
        type: 'Feature',
        geometry: null,
        properties: {
          ip,
          country: null,
          note: 'no-geo',
          source: 'geoip-lite',
          ts: new Date().toISOString()
        }
      });
    }
  }
  return features;
}

(async () => {
  try {
    const text = readInput();
    const inds = extractIndicators(text);
    console.log(`[+] Extracted: ${inds.ips.length} IP(s), ${inds.domains.length} domain(s), ${inds.emails.length} email(s)`);

    const ipFeatures = enrichIPs(inds.ips);
    // Add domain/email as properties only (optionally geocode domains via DNS/WHOIS externally)
    const otherFeatures = [];
    for (const d of inds.domains) {
      otherFeatures.push({
        type: 'Feature',
        geometry: null,
        properties: { domain: d, type: 'domain', ts: new Date().toISOString() }
      });
    }
    for (const e of inds.emails) {
      otherFeatures.push({
        type: 'Feature',
        geometry: null,
        properties: { email: e, type: 'email', ts: new Date().toISOString() }
      });
    }

    const featureCollection = {
      type: 'FeatureCollection',
      features: [...ipFeatures, ...otherFeatures]
    };

    fs.writeFileSync(opts.out, JSON.stringify(featureCollection, null, 2));
    console.log(`[+] Wrote GeoJSON → ${opts.out}`);

    if (opts.map) {
      const port = parseInt(opts.port, 10) || 3000;
      const app = express();
      const root = path.join(__dirname, '.qadr_map_static');
      if (!fs.existsSync(root)) fs.mkdirSync(root, { recursive: true });
      // write map.html into static folder
      const mapHtmlPath = path.join(root, 'map.html');
      const mapTemplate = fs.readFileSync(path.join(__dirname, 'map.html'), 'utf8');
      fs.writeFileSync(mapHtmlPath, mapTemplate);

      // serve static and geojson
      app.use(express.static(root));
      app.get('/data/geo.json', (req, res) => {
        res.type('application/json').send(JSON.stringify(featureCollection));
      });

      const server = app.listen(port, '127.0.0.1', () => {
        const url = `http://127.0.0.1:${port}/map.html`;
        console.log(`[+] Map server running: ${url}`);
        (async () => {
          try { await open(url); } catch (e) { /* ignore */ }
        })();
      });

      // graceful shutdown on SIGINT
      process.on('SIGINT', () => {
        server.close(() => {
          console.log('\n[+] server stopped');
          process.exit(0);
        });
      });
    }
  } catch (err) {
    console.error('[!] Error:', err.message || err);
    process.exit(1);
  }
})();
package.json
{
  "name": "qadr-geo-cli",
  "version": "0.1.0",
  "description": "QADR-GEO lightweight CLI: extract indicators, geoip, export GeoJSON, serve a map",
  "main": "qadr-geo.js",
  "bin": {
    "qadr-geo": "./qadr-geo.js"
  },
  "scripts": {
    "start": "node qadr-geo.js"
  },
  "dependencies": {
    "commander": "^11.0.0",
    "express": "^4.18.2",
    "geoip-lite": "^1.4.2",
    "open": "^9.0.0"
  }
}
npm install
chmod +x qadr-geo.js
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QADR GEO - Map</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  html,body,#map { height: 100%; margin: 0; padding: 0; }
  .legend { background: white; padding: 6px; border-radius:4px; }
</style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
async function init() {
  const map = L.map('map').setView([20,0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom: 19 }).addTo(map);

  const res = await fetch('/data/geo.json');
  const geo = await res.json();

  function pointToLayer(feature, latlng) {
    return L.circleMarker(latlng, { radius:6, weight:1, fillOpacity:0.9 });
  }

  const markers = L.geoJSON(geo, {
    pointToLayer,
    filter: f => !!f.geometry && f.geometry.type === 'Point',
    onEachFeature: (f, layer) => {
      const p = f.properties || {};
      let html = '<b>QADR Event</b><br/>';
      if (p.ip) html += `IP: ${p.ip}<br/>`;
      if (p.country) html += `Country: ${p.country}<br/>`;
      if (p.city) html += `City: ${p.city}<br/>`;
      if (p.domain) html += `Domain: ${p.domain}<br/>`;
      if (p.email) html += `Email: ${p.email}<br/>`;
      html += `Time: ${p.ts || ''}`;
      layer.bindPopup(html);
    }
  }).addTo(map);

  // Fit to markers if any
  const has = geo.features.filter(f => f.geometry && f.geometry.type === 'Point');
  if (has.length) {
    const group = L.featureGroup(has.map(f => L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]])));
    map.fitBounds(group.getBounds().pad(0.2));
  }
}
init().catch(err => {
  document.body.innerHTML = '<pre>Error loading map: '+err+'</pre>';
});
</script>
</body>
</html>
